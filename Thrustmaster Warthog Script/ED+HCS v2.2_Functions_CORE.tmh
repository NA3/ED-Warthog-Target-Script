//	Copyright (C) 2017 Thomas Duployez (CMDR Touille)
//	V2.2.03.2b	2017/01
//	Distributed freely under the MIT License.
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	PIP MANAGEMENT FUNCTIONS																																	//
//		initPIPPower(x,y,z)	Params = SYS, ENG, WEP, MID																											//
//			x gets 4 PIPs, y gets 2 PIPs, if z = MID get 50/50 of x and y (3x 3y)																				//
//			If only x, balanced 1 PIP on each 2ndary power																										//
//			If no params, balances power.																														//
//		initRestorePIPPower(j)	Params = vOptimalPIP[XXXXX]Backup	(ex: initRestorePIPPower(vOptimalPIPFireBackup) )											//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	//PIP Management
	int initPIPPower(int x=0, int y=0, int z=0){

		// Check Wich Command to Send and if it need to be Send
		if(x == 0 & y == 0 & z == 0){if(vOptimalPIP != 0){vOptimalPIP = 0; vPIP=!vPIP;}}	//2 SYS 2 ENG 2 WEP (0)
		else if(z != MID | z == 0){
			if(y != 0){
				if(y == SYS){
					if(x == ENG){if(vOptimalPIP != 1){vOptimalPIP = 1; vPIP=!vPIP;}}		//4 ENG	2 SYS (1)
					else if(x == WEP){if(vOptimalPIP != 6){vOptimalPIP = 6; vPIP=!vPIP;}}	//4 WEP 2 SYS (6)
				}else if(y == ENG){
					if(x == SYS){if(vOptimalPIP != 3){vOptimalPIP = 3; vPIP=!vPIP;}}		//4 SYS 2 ENG (3)
					else if(x == WEP){if(vOptimalPIP != 5){vOptimalPIP = 5; vPIP=!vPIP;}}	//4 WEP 2 ENG (5)
				}else if(y == WEP){
					if(x == SYS){if(vOptimalPIP != 4){vOptimalPIP = 4; vPIP=!vPIP;}}		//4 SYS 2 WEP (4)
					else if(x == ENG){if(vOptimalPIP != 2){vOptimalPIP = 2; vPIP=!vPIP;}}	//4 ENG 2 WEP (2)
				}
			}else if(y ==0){
				if(x == SYS){if(vOptimalPIP != 10){vOptimalPIP = 10; vPIP=!vPIP;}}			//4 SYS 1 ENG 1 WEP (10)
				else if(x == ENG){if(vOptimalPIP != 11){vOptimalPIP = 11; vPIP=!vPIP;}}		//4 ENG 1 SYS 1 WEP (11)
				else if(x == WEP){if(vOptimalPIP != 12){vOptimalPIP = 12; vPIP=!vPIP;}}		//4 WEP 1 SYS 1 ENG (12)
			}
		}else if(z == MID){	
			if(y == SYS & x == ENG | y == ENG & x == SYS){if(vOptimalPIP != 7){vOptimalPIP = 7; vPIP=!vPIP;}}		//3 SYS 3 ENG (7)
			else if(y == ENG & x == WEP | y == WEP & x == ENG){if(vOptimalPIP != 8){vOptimalPIP = 8; vPIP=!vPIP;}}	//3 ENG 3 WEP (8)
			else if(y == SYS | x == WEP | y == WEP | x == SYS){if(vOptimalPIP != 9){vOptimalPIP = 9; vPIP=!vPIP;}}	//3 SYS 3 WEP (9)
		}
		if(vPIP){	//If Previous Command is NOT the same as the New one, Push Command
			vPIP=!vPIP;
			if(DebugMode) printf("Initialising PIP Mode	[%d]\x0a", vOptimalPIP);
			
			// Map out PIPs
			if(x == 0) PIPx = 0;
			else if(x == SYS) PIPx = PULSE+ PowerSys;
			else if(x == ENG) PIPx = PULSE+ PowerEng;
			else if(x == WEP) PIPx = PULSE+ PowerWep;
			
			if(y == 0) PIPy = 0;
			else if(y == SYS) PIPy = PULSE+ PowerSys;
			else if(y == ENG) PIPy = PULSE+ PowerEng;
			else if(y == WEP) PIPy = PULSE+ PowerWep;
			
			if(z == 0 & z != MID) PIPz = 0;
			else if(z == MID) PIPz = PIPy;
			
			// Send PIPS
			ActKey(KEYON+ CHAIN(PULSE+ BalancePower, D(PIPPulseDelay),PIPx, D(PIPPulseDelay),PIPy, D(PIPPulseDelay),PIPx, D(PIPPulseDelay),PIPx, D(PIPPulseDelay),PIPz));
			
		}else{
			//if(DebugMode) printf("This PIP is Already Pushed	[%d]\x0a", vOptimalPIP);	
		}			
	}

	//PIP Restore Management
	int initRestorePIPPower(int j=0){
		if(j != vOptimalPIP){	// Send Good Backup PIPS only if previous PIP Swith is != of Backuped Value
			//if(DebugMode){printf("Reset PIP ?: PIPRestore [%d] vOptimalPIP [%d]\x0a", j, vOptimalPIP);}
			if(j == 0)initPIPPower();					//2 SYS 2 ENG 2 WEP (0)
			else if(j == 1)initPIPPower(ENG,SYS);		//4 ENG	2 SYS (1)
			else if(j == 2)initPIPPower(ENG,WEP);		//4 ENG 2 WEP (2)
			else if(j == 3)initPIPPower(SYS,ENG);		//4 SYS 2 ENG (3)
			else if(j == 4)initPIPPower(SYS,WEP);		//4 SYS 2 WEP (4)
			else if(j == 5)initPIPPower(WEP,ENG);		//4 WEP 2 ENG (5)
			else if(j == 6)initPIPPower(WEP,SYS);		//4 WEP 2 SYS (6)
			else if(j == 7)initPIPPower(SYS,ENG,MID);	//3 SYS 3 ENG (7)
			else if(j == 8)initPIPPower(ENG,WEP,MID);	//3 ENG 3 WEP (8)
			else if(j == 9)initPIPPower(SYS,WEP,MID);	//3 SYS 3 WEP (9)	
			else if(j == 10)initPIPPower(SYS);			//4 SYS 1 ENG 1 WEP (10)
			else if(j == 11)initPIPPower(ENG);			//4 ENG 1 SYS 1 WEP (11)
			else if(j == 12)initPIPPower(WEP);			//4 WEP 1 SYS 1 ENG (12)
		}else{
			//if(DebugMode) printf("This PIP is Already OK	[%d]\x0a", vOptimalPIP);	
		}
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	FUNCTIONS																																					//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	//FUNCTION FPS & CONNECTION STATUS
	int initFPSCONNECTION(){
		ActKey(KEYON+PULSE+ShowFramerate);
		ActKey(KEYON+PULSE+ShowConnectionStatus);
		if(DebugMode)printf("FPS & CONNECTION STATUS\x0a");
	}
	
	//FUNCTION: Head Center
	int initHeadCenter(){
		if(HMD){ActKey(KEYON+PULSE+HMDCenter); if(DebugMode)printf("HMD Center\x0a");}
		else if(TrackIR){ActKey(KEYON+PULSE+TrackIRCenter); if(DebugMode)printf("TrackIR Center\x0a");}
		else{ActKey(KEYON+PULSE+UIFocus); if(DebugMode)printf("UI Focus\x0a");}
	}
	
	//FUNCTION: Voice PTT
	int initVoicePTT(){
		if(sPTTState)vPTT = InternalVoiceCommsPTT;	//External Mic
		else if(!sPTTState)vPTT = ExternalVoiceCommsPTT;	//Internal Mic
		if(Throttle[MSP]){
			vVoicePTT=!vVoicePTT;
			if(sPTTMode){	//TOGGLE
				vVoice=!vVoice;
				ActKey(KEYON+PULSE+vPTT);
				if(vVoice)ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 1);"));
				else ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 0);"));
				if(DebugMode) printf("Mic Toggle [%d] [Actived[1] DesActived[0] / PTT [%d] [External:[0]Internal:[1]] / Mode [%d] [HOLD:[0] TOGGLE:[1]]\x0a", vVoicePTT, sPTTState, sPTTMode);
			}else{	//Talk [HOLD]
				ActKey(KEYON+DOWN+vPTT);
				ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 1);"));
			}
		}
		if(!Throttle[MSP] & !sPTTMode){	//Silence [HOLD]
			vVoicePTT=!vVoicePTT;
			ActKey(KEYON+UP+vPTT);
			ActKey(KEYON+PULSE+EXEC("initLED(ToggleVoicePTTLED, 0);"));
		}
		if(DebugMode & !sPTTMode) printf("Mic Toggle [%d] [Actived[1] DesActived[0] / PTT [%d] [External:[0]Internal:[1]] / Mode [%d] PUSH:[0] TOGGLE:[1]]\x0a", vVoicePTT, sPTTState, sPTTMode);
	}
	
	//FUNCTION: Init Secure Retract
	int initSecureRectract(){
		vSecureEscapeFight=!vSecureEscapeFight;
		if(sHardPoints) ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
		if(sGears) ActKey(KEYON+PULSE+EXEC("initToggleLandingGear();"));
		if(sCargo) ActKey(KEYON+PULSE+EXEC("initToggleCargoScoop();"));
		vSecureEscapeFight=!vSecureEscapeFight;
	}

	//FUNCTION: Toggle LED	requested, Params = Toggle Name LED, ON[1] or OFF[0] (ex:	initLED(ToggleLandingGearLED, 1)	Will up the LG LED if ToggleLandingGearLED is Define in setting (!=0))
	int initLED(int l = 0, int LEDONOFF =0){
		if(LEDONOFF == 1 & l!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+l));	//LED ON
		if(LEDONOFF == 0 & l!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-l));	//LED OFF
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	MAIN GAMES FUNCTIONS																																		//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Init Fire
	int initFire(){
		if(Joystick[TG1] | Joystick[S2]){	//PRESS THE TG1 or S2 BUTTON	
			if(SilentRuningOFFonFire & sSilentRuning){
				if(!vSLonFire){	//ShutDown Silent Runing
					vSLonFire=!vSLonFire;
					vSilentRuningBackup = sSilentRuning;	//Backup Actual Silent Runing State
					ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
				}
			}
			if(HardPointsonFireGameMode & !sHardPoints){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			if(OptimalPIPMode & !sExplorerMode){
				vOptimalPIPFireBackup = vOptimalPIP;	//Backup Actual PIP Mode
				ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));	//4 WEP 2 SYS (6)
			}			
			if(Joystick[TG1]){ActKey(KEYON+DOWN+PrimaryFire);}
			if(Joystick[S2]){ActKey(KEYON+DOWN+SecondaryFire);}
			//if(DebugMode)printf("vSLonFire [%d]\x0a", vSLonFire);
		}else{				//RELEASE THE TG1 or S2 BUTTON
			if(!Joystick[TG1]){ActKey(KEYON+UP+PrimaryFire);}
			if(!Joystick[S2]){ActKey(KEYON+UP+SecondaryFire);}
			if(OptimalPIPMode & !Joystick[TG1] & !Joystick[S2] & !sExplorerMode){
				ActKey(KEYON+PULSE+EXEC("initRestorePIPPower(vOptimalPIPFireBackup);"));	//Restore Previous PIP Mode		
			}
			if(HardPointsonFireGameMode & StopFireRetractHardpoints & sHardPoints & !Joystick[S2] & !Joystick[TG1] & !sExplorerMode){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			if(vSilentRuningBackup!=0 & !Joystick[S2] & !Joystick[TG1]){
				vSilentRuningBackup = 0;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));	//Restore Silent Runing State
			}
			if(SilentRuningOFFonFire & sSilentRuning & vSLonFire & !Joystick[S2] & !Joystick[TG1]){
				vSLonFire=!vSLonFire;
			}
			//if(DebugMode)printf("vSLonFire [%d]\x0a", vSLonFire);
		}
	}
	
	//FUNCTION: Jettison All Cargo	
	int initJettisonCargo(){
		if(Throttle[APUON]){
			if(sCargo){
				ActKey(KEYON+PULSE+JettisonAllCargo);
				if(DebugMode) printf("Jettison All Cargo\x0a");
			}else{
				if(DebugMode) printf("Jettison Need Cargo Scoop Open\x0a");
			}
		}
	}

	//FUNCTION: Init Supercruise
	int initSuperCruise(){
		if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		ActKey(KEYON+PULSE+Supercruise);
		if(DebugMode) printf("Engage SuperCruise\x0a");
	}
	
	//FUNCTION: Init FrameShiftDrive
	int initFrameShiftDrive(){
		if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		ActKey(KEYON+PULSE+FrameShiftDrive);
		if(DebugMode) printf("Engage FSD\x0a");
	}
	
	//FUNCTION: SystemJump
	int initSystemJump(){
		if(!SecureRetract & (sHardPoints | sCargo | sGears)){		//IF SecureRectract = 0 Engage FSD To match the game mechanic and don't launch the speed to 0 from mSystemJump Macro if HardPoints or Cargo Scoop Or L Gears Deployed
			ActKey(KEYON+PULSE+EXEC("initFrameShiftDrive();"));
		}else{
			if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
			ActKey(KEYON+PULSE+mSystemJump);
			if(DebugMode) printf("Engage System Jump\x0a");
		}
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	EXTRA GAMES FUNCTIONS																																		//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Use Supercruise while boosting if Throttle is 100%
	int initThrottleBoost(){
		if(SupecruiseOnThrottle & AxisVal(Throttle[THR_RIGHT], &axdata) >= 32767){	//Throttle All the Way Up & SupecruiseOnThrottle is Actived?
			if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
			ActKey(KEYON+PULSE+Supercruise);
			if(DebugMode) printf("SuperCruise On Throttle Engaged\x0a");
		}else{
			ActKey(KEYON+PULSE+EngineBoost);
			if(DebugMode) printf("Engine Boost\x0a");
		}
	}

	//FUNCTION: Escape Fight	All we want is to Escape Fight so We don't check SecureRetract & OptimalPIPMode, if you want, you can UnComment the 4 Lines to check Them
	int initEscapeFight(){
		//if(SecureRetract){	//If you want to check if SecureRetract is Enable UnComment this line
			if(sHardPoints | sCargo | sGears){
				initSecureRectract();	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
			}
		//}	//If you want to check if SecureRetract is Enable UnComment this line	
		if(!sSilentRuning & !vSLonEscapeFight){	//If Silent Running is Disable, Enable it
			vSLonEscapeFight=!vSLonEscapeFight;
			initToggleSilentRuning();
		}
		//if(OptimalPIPMode){	//If you want to check if OptimalPIPMode is Enable UnComment this line
			vOptimalPIPEFBackup = vOptimalPIP;	//Backup Actual PIP Mode
			initPIPPower(ENG, SYS);	//4 ENG	2 SYS (1)
			DeferCall(1500, &ActKey, KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
			DeferCall(10000, &initRestorePIPPower, vOptimalPIPEFBackup);	//Restore Previous PIP Mode If vOptimalPIPEFBackup != 4 SYS 2 ENG (3)
		//}	//If you want to check if OptimalPIPMode is Enable UnComment this line
		ActKey(KEYON+PULSE+mEscapeFight);
		if(sSilentRuning){		//Disable Silent Runing previouly Enable
			DeferCall(4000, &ActKey, KEYON+PULSE+EXEC("initToggleSilentRuning();"));
			if(vSLonEscapeFight){
				DeferCall(5000, &ActKey, KEYON+PULSE+EXEC("vSLonEscapeFight=!vSLonEscapeFight;"));
			}
		}
		if(DebugMode) printf("Escape Mode Engaged : CHECK IF GEARS AND CARGO STATE IS OK (SWITCH CS and LG) \x0a");
	}

	//FUNCTION: Request Docking
	int initRCDocking(){
		if(DebugMode) printf("Docking Initialisation\x0a");
		if(SecureRetract & (sHardPoints | sCargo | sGears)){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));}	//initSecureRectract() only if HardPoints or Cargo Scoop Or L Gears Deployed
		ActKey(KEYON+PULSE+mRequestCancelDock);
		if(OptimalPIPMode){
			DeferCall(3000, &ActKey, KEYON+PULSE+EXEC("initPIPPower(SYS, ENG);"));	//4 SYS 2 ENG (3)
		}
	}

	//FUNCTION: Autopilot Engage / Disengage Key
	int initEngageAPkey(){
		if (Throttle[APPAT]) ActKey(KEYON+PULSE+EXEC("initRCDocking();"));
		else if (Throttle[APAH]) ActKey(KEYON+PULSE+EXEC("initEscapeFight();"));
		else if (Throttle[APALT] & !Joystick[S3]) ActKey(KEYON+PULSE+EXEC("initSystemJump();"));
		else if (Throttle[APALT] & Joystick[S3]) ActKey(KEYON+PULSE+CancelFSD);
	}