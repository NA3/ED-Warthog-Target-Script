//	Copyright (C) 2017 Thomas Duployez (CMDR Touille)
//	V2.2.03.2b	2017/01
//	Distributed freely under the MIT License.
//	
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//	
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//	
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	HARDWARE MAPPINGS																																			//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Toggle LED	Params = Toggle Name LED, Value to Track (ex: initLED(ToogleHeadLookLED, sHeadLook);	Will up or down the HeadLook LED if ToogleHeadLookLED is Define in setting (!=0))
	int initLED(int t = 0, int v =0){
		if(t!=0){
			if     (v == 1)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+t));	//LED ON
			else if(v == 0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-t));	//LED OFF
		}else{
			//if(DebugMode) printf("LED SET	[%d]	Value	[%d]\x0a", t, v);
		}
	}

	//	-------------------------Set LED
	int initLEDStates(){
	
		//Initiate LED Backlight power on Throttle (Value 0-255)
		if(HMD){	//Set LED Backlight on Start If HMD
				vThrottleLight = ThrottleLightHMD;
				vThrottleLightBackup = ThrottleLightHMD;	//Backup the LED Backlight defaukt value
				if(DebugMode | DebugMMode)printf("HMD -> Backlight IDLE Throttle LED Set to %d\x0a", ThrottleLightHMD);
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, ThrottleLightHMD));
		}else{	//Set LED Backlight on Start
				vThrottleLight = ThrottleLight;
				vThrottleLightBackup = ThrottleLight;	//Backup the LED Backlight defaukt value
				if(DebugMode | DebugMMode)printf("No HMD Or TrackIR -> Backlight IDLE Throttle LED Set to %d\x0a", vThrottleLight);
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, ThrottleLight));
		}

		//Initiate LED Backlight power On MFD
		if(USEMFD > 0)ActKey(PULSE+KEYON+LED(&RMFD, LED_INTENSITY, RMFDLight));
		if(USEMFD > 1)ActKey(PULSE+KEYON+LED(&LMFD, LED_INTENSITY, LMFDLight));

		//Initiate LED status all OFF
		ActKey(PULSE+KEYON+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1));
		ActKey(PULSE+KEYON+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED2));
		ActKey(PULSE+KEYON+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3));
		ActKey(PULSE+KEYON+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4));
		ActKey(PULSE+KEYON+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5));
		if(USEMFD > 0){
			ActKey(PULSE+KEYON+LED(&RMFD, LED_ONOFF, LED_CURRENT-LED1));	//set right MFD LED 1 OFF
			ActKey(PULSE+KEYON+LED(&RMFD, LED_ONOFF, LED_CURRENT-LED2));	//set right MFD LED 2 OFF
		}
		if(USEMFD > 1){
			ActKey(PULSE+KEYON+LED(&LMFD, LED_ONOFF, LED_CURRENT-LED1));	//set left MFD LED 1 OFF
			ActKey(PULSE+KEYON+LED(&LMFD, LED_ONOFF, LED_CURRENT-LED2));	//set left MFD LED 2 OFF
		}			
		
		//Initiate Led State
		initLED(ToggleSuperCruiseModeLED, SupecruiseOnThrottle);
		initLED(ToggleRCorrectionLED, sRCorrection);
		initLED(ToggleLandingGearLED, sGears);
		initLED(ToggleCargoScoopLED, sCargo);
		initLED(ToggleLightsLED, sLights);
		initLED(ToggleHardpointsLED, sHardPoints);
		initLED(ToggleCombinedFireLED, sCombinedFire);
		initLED(TogglePTTLED, sPTTState);
		initLED(ToggleVoicePTTLED, vVoicePTT);
		initLED(TogglePTTModeLED, sPTTMode);
		initLED(ToggleSilentRuningonFireLED, SilentRuningOFFonFire);
		initLED(ToggleHeatSinkonSilentRuningLED, HeatSinkonSilentRuning);
		initLED(ToggleIDLEonThrottleLED, sIDLE);
		initLED(ToggleOptimalPIPModeLED, OptimalPIPMode);
		initLED(ToggleSecureRetractLED, SecureRetract);
		initLED(ToggleStopFireRetractHardpointsLED, StopFireRetractHardpoints);
		initLED(ToogleExplorerModeLED, sExplorerMode);
		
		//initLED(ToggleHardPointsonFireGameModeLED, HardPointsonFireGameMode);
		//initLED(ToggleFALED, sFlightAssist);
		//initLED(ToggleVALED, sVoiceAttack);
		//initLED(ToggleSilentRuningLED, sSilentRuning);
		//initLED(ToggleReverseThrottleLED, sRT);		
		//initLED(ToggleCameraLED, sCameraMode);
		//initLED(ToggleGameMenuLED, sGameMenu);
		//initLED(ToogleHeadLookLED, sHeadLook);
		
	}
	
	//	-------------------------Set Joystick
	//Set Default Joystick Axis
	int initJoystickAxis(){	
		MapAxis(&Joystick, JOYX, DX_X_AXIS,    AXIS_NORMAL, MAP_ABSOLUTE);	// Set Joystick Control X Axis
		MapAxis(&Joystick, JOYY, DX_Y_AXIS,    AXIS_NORMAL, MAP_ABSOLUTE);	// Set Joystick Control Y Axis
		MapAxis(&Throttle, SCX,  DX_XROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);	// Set Slew Control X Axis
		MapAxis(&Throttle, SCY,  DX_YROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);	// Set Slew Control Y Axis
	}

	//Joystick Curve Profile Three different presets are selectable On The Fly (FLAP position)
	int initSetJoystickCurves(){
		if(Throttle[FLAPU]) vJoystickCurveProfile = 0;
		if(!Throttle[FLAPU] & !Throttle[FLAPD]) vJoystickCurveProfile = 1;
		if(Throttle[FLAPD]) vJoystickCurveProfile = 2;
		initJoystickCurves();
	}
	
	//Joystick Curve Initialising
	int initJoystickCurves(){
		SetSCurve(&Joystick, JOYX, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
		SetSCurve(&Joystick, JOYY, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
		SetSCurve(&Throttle, SCX,  0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		SetSCurve(&Throttle, SCY,  0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		if (DebugMode){
			printf("Set	Joystick	Curve Profile	[%d]: Curve=%d, Zoom=%d\x0a", vJoystickCurveProfile, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
			printf("Set	Slew		Curve Profile	[%d]: Curve=%d, Zoom=%d\x0a", vJoystickCurveProfile, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
		}
	}
	
	//	-------------------------Set Throttle
	//Set Default Throttle Axis
	int initThrottleAxis(){	
		MapAxis(&Throttle, THR_RIGHT, DX_Z_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);					// Set Right Throttle
		MapAxis(&Throttle, THR_LEFT, 0, AXIS_NORMAL, MAP_ABSOLUTE);								// Set Left Throttle / DX_ZROT_AXIS / We don't Use It Yet In ED
		MapAxis(&Throttle, THR_FC, DX_SLIDER_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);					// Set Friction Control Axis Curve (Sensor Range Zoom Scaling) 
		SetCustomCurve(&Throttle, THR_FC, LIST(0,0, 33,25, 66,50, 80,75, 100,100));				// (OPTIONAL OVERRIDE) (Linear Recommended in ED) *LIST(Axis physical position, Axis output Value)
	}
	
	//Set Throttle Curve two different presets are selectable On The Fly (S3 + RED Button on Throttle Arm)
	int initSetThrottleCurves(){
		vThrottleCurveProfile=!vThrottleCurveProfile;
		if(vThrottleCurveProfile){
			if(!AfterburnerDetent)SetJCurve(&Throttle, THR_RIGHT, 50, 50);	//Without Warthog Physical Afterburner Detent
			else SetJCurve(&Throttle, THR_RIGHT, 65, 95); //At 65% of the physical controller’s axis travel, the DirectX axis must have reached 95% of the axis value.
		}else{
			if(ThrottleAxisRange)SetSCurve(&Throttle, THR_RIGHT, 0, 0, 0, 2, -3);	//Full Range Precision
			else SetSCurve(&Throttle, THR_RIGHT, 0, 0, 0, 3, -3);	//Forward only Precision
		}
		DXAxis(DX_Z_AXIS, -AxisVal(Throttle[THR_RIGHT], &axdata));
		if(DebugMode)printf("Set	Throttle	Curve Profile[%d}\x0a", vThrottleCurveProfile);
	}

	//	-------------------------Set Rudders	
	//Set Rudders Axis
	int initRudders(){
		MapAxis(&TFRPRudder, TRUDDER,  DX_Z_AXIS, AXIS_NORMAL,   MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPLEFT,  DX_X_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPRIGHT, DX_Y_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
	}