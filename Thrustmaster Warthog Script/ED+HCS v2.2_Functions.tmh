//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// TOGGLE FUNCTIONS 																																			//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	// TOGGLE: Landing Gear	
	int initToggleLandingGear(){
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
//			if(DebugMode)printf("Landing Gear SecureEscapeFightState [%d]\x0a", SecureEscapeFightState);
			if(!vSecureEscapeFight){if (Throttle[EACON]) sGears = 1; else sGears = 0;}
			else sGears=!sGears; // reverse the flag status
			ActKey(KEYON+PULSE+LandingGear);
			if(sGears){																							 
				if(DebugMode)printf("Landing Gear: DEPLOYED [%d]\x0a", sGears);
				if(ToggleLandingGearLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleLandingGearLED)); 					// ToggleLandingGearLED ON
			}else{
				if(DebugMode)printf("Landing Gear: RETRACTED [%d]\x0a",  sGears);
				if(ToggleLandingGearLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleLandingGearLED)); 					// ToggleLandingGearLED OFF
			}
		}
	}
	
	// TOGGLE: Cargo Scoop	
	int initToggleCargoScoop() {																
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
//			if(DebugMode)printf("Cargo Scoop SecureEscapeFightState [%d]\x0a", SecureEscapeFightState);
			if(!vSecureEscapeFight){if (Throttle[RDRNRM]) sCargo = 1; else sCargo = 0;}
			else sCargo=!sCargo; // reverse the flag status
			ActKey(KEYON+PULSE+CargoScoop);
			if(sCargo){																								
				if(DebugMode)printf("Cargo Scoop: DEPLOYED [%d]\x0a", sCargo);
				if(ToggleCargoScoopLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleCargoScoopLED)); 					// ToggleCargoScoopLED ON
			}else{
				if(DebugMode)printf("Cargo Scoop: RETRACTED [%d]\x0a", sCargo);
				if(ToggleCargoScoopLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleCargoScoopLED)); 					// ToggleCargoScoopLED OFF
			}
		}
	}

	// TOGGLE: Light	
	int initToggleLights(){
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if (Throttle[EFRNORM]) sLights = 1; else sLights = 0;
			ActKey(KEYON+PULSE+ShipLights);
			if(sLights){																							
				if(DebugMode)printf("Light: ON [%d]\x0a", sLights);
				if(ToggleLightsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleLightsLED)); 						// ToggleLightsLED ON
			}else{
				if(DebugMode)printf("Light: OFF [%d]\x0a", sLights);
				if(ToggleLightsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleLightsLED)); 						// ToggleLightsLED OFF
			}
		}
	}
	
	// TOGGLE: HardPoints	
	int initToggleHardpoints(){
		if(Joystick[S3]){
			sHardPoints=!sHardPoints; // reverse the flag status
			if(DebugMode)printf("HardPoints: State Reset\x0a");
		}		
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(vSecureEscapeFight){
				if(DebugMode)printf("HardPoints SecureEscapeFightState [%d]\x0a", vSecureEscapeFight);
			}
			sHardPoints=!sHardPoints; // reverse the flag status
			ActKey(KEYON+PULSE+DeployHardpoints);
			if(sHardPoints){
				if(DebugMode)printf("HardPoints: DEPLOYED [%d]\x0a", sHardPoints);
				if(OptimalPIPMode){
					vOptimalPIPBackup = vOptimalPIP;
					ActKey(KEYON+PULSE+EXEC("initPIPmPowerWepSys();"));
					if(DebugMode)printf("HardPoints: Optimal PIP Mode Set\x0a");
				}
				if(ToggleHardpointsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleHardpointsLED)); 				// ToggleHardpointsLED ON
			}else{
				if(DebugMode)printf("HardPoints: RETRACTED [%d]\x0a", sHardPoints);
				if(OptimalPIPMode){
					if(vOptimalPIPBackup == 0)ActKey(KEYON+PULSE+EXEC("initPIPmPowerEngSys();")); 					//If no PIP Mode is switched after the game launch and before Toggle Hardpoints
					if(vOptimalPIPBackup == 1)ActKey(KEYON+PULSE+EXEC("initPIPmPowerEngSys();"));
					if(vOptimalPIPBackup == 2)ActKey(KEYON+PULSE+EXEC("initPIPmPowerEngWep();"));
					if(vOptimalPIPBackup == 3)ActKey(KEYON+PULSE+EXEC("initPIPmPowerSysEng();"));
					if(vOptimalPIPBackup == 4)ActKey(KEYON+PULSE+EXEC("initPIPmPowerSysWep();"));
					if(vOptimalPIPBackup == 5)ActKey(KEYON+PULSE+EXEC("initPIPmPowerWepEng();"));
					if(vOptimalPIPBackup == 6)ActKey(KEYON+PULSE+EXEC("initPIPmPowerWepSys();"));
					if(vOptimalPIPBackup == 7)ActKey(KEYON+PULSE+EXEC("initPIPmPowerTank();"));
					if(vOptimalPIPBackup == 8)ActKey(KEYON+PULSE+EXEC("initPIPmPowerOffensive();"));
					if(DebugMode)printf("HardPoints: Optimal PIP Mode Reset [%d]\x0a", vOptimalPIPBackup);
				}
				if(ToggleHardpointsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleHardpointsLED)); 					// ToggleHardpointsLED OFF
			}
		}
	}
	
	// TOGGLE: Combined Fire	
	int initToggleCombinedFire(){
		if(sCombinedFire){
			MapKey(&Joystick, TG2, CHAIN(PrimaryFire, SecondaryFire));
			if(DebugMode)printf("COMBINED Primary & Secondary Fire 1? [%d]\x0a", sCombinedFire);
			if(ToggleCombinedFireLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleCombinedFireLED));						// ToggleCombinedFireLED ON
		}else{
			MapKey(&Joystick, TG2, 0);
			if(DebugMode)printf("SEPARATE Primary & Secondary Fire 0? [%d]\x0a", sCombinedFire);
			if(ToggleCombinedFireLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleCombinedFireLED));						// ToggleCombinedFireLED Off
		}
		sCombinedFire=!sCombinedFire;// reverse the flag status
	}

	// TOGGLE: Rotational Correction
	int initToggleRotationCorrection(){	
		ActKey(KEYON+PULSE+RotationalCorrection);
		if(Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(DebugMode)printf("Rotational Correction: RESET STATE\x0a");
		}else{
			sRCorrection=!sRCorrection;// reverse the flag status
			if(sRCorrection){
				if(DebugMode)printf("Rotation Correction: ENABLED [%d]\x0a", sRCorrection);
				if(ToggleRCorrectionLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleRCorrectionLED)); 					// ToggleRotationCorrectionLED ON
			}else{
				if(DebugMode)printf("Rotation Correction: DISABLED [%d]\x0a", sRCorrection);
				if(ToggleRCorrectionLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleRCorrectionLED)); 					// ToggleRotationCorrectionLED OFF
			}
		}
	}

	// TOGGLE: Classified (External) 'Debug' Camera
	int initToggleCamera(){
		sCameraMode=!sCameraMode; // reverse the flag status
		ActKey(KEYON+PULSE+ClassifiedCamera);
		if(sCameraMode){
			ActKey(KEYON+PULSE+SetSpeed0);
			DeferCall(60, &ActKey, KEYON+PULSE+SPC);
			if(DebugMode)printf("Classified Camera Mode: ON [%d]\x0a", sCameraMode);
			if(ToggleCameraLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleCameraLED)); 							// ToggleCameraLED OFF
		}else{
			if(DebugMode)printf("Classified Camera Mode: OFF [%d]\x0a", sCameraMode);
			if(ToggleCameraLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleCameraLED)); 							// ToggleCameraLED OFF
		}
	}
	
	// TOGGLE: PTT/PTP & External/Internal Voice
	int initTogglePTT(){
		if(!Joystick[S3]){																								
			sPPTMode=!sPPTMode; // reverse the flag status
			if(DebugMode)printf("PTTMode Change [%d]\x0a", sPPTMode);
		}else{
			sPTTState=!sPTTState;// reverse the flag status
			if(sPTTState){
				if(DebugMode)printf("Mic State External PTT[%d]\x0a", sPTTState);
				if(TogglePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+TogglePTTLED)); 							// ToggleMicLED ON
			}else{
				if(DebugMode)printf("Mic State Internal PTT[%d]\x0a", sPTTState);
				if(TogglePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-TogglePTTLED)); 							// ToggleMicLED OFF
			}
		}
	}

	// TOGGLE: Supecruise On Throttle Mode
	int initToggleSuperCruiseMode(){
		SupecruiseOnThrottle=!SupecruiseOnThrottle; // reverse the flag status
		if(SupecruiseOnThrottle){
			if(DebugMode)printf("Supecruise On Throttle Mode: ON [%d]\x0a", SupecruiseOnThrottle);
			if(ToggleSuperCruiseModeLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSuperCruiseModeLED)); 					// ToggleSuperCruiseModeLED ON
		}else{
			if(DebugMode)printf("Supecruise On Throttle Mode: OFF [%d]\x0a", SupecruiseOnThrottle);
			if(ToggleSuperCruiseModeLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSuperCruiseModeLED)); 					// ToggleSuperCruiseModeLED ON
		}
	}
	
	// TOGGLE: Silent Runing
	int initToggleSilentRuning(){
		sSilentRuning=!sSilentRuning; // reverse the flag status
		if(sSilentRuning){
			if(HeatSinkOnSilentRuning){
				ActKey(KEYON+PULSE+mHeatSinkOnSilentRuning);
				if(DebugMode)printf("Heat Sink On Silent Runing Engaged [%d]\x0a", sSilentRuning);
			}else{
				ActKey(KEYON+PULSE+SilentRunning);
			}
			if(DebugMode)printf("Silent Runing Engaged [%d]\x0a", sSilentRuning);
			if(ToggleSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSilentRuningLED));						// ToggleSilentRuningLED ON
		}else{
			ActKey(KEYON+PULSE+SilentRunning);
			if(DebugMode)printf("Silent Runing DisEngaged [%d]\x0a", sSilentRuning);
			if(ToggleSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSilentRuningLED));						// ToggleSilentRuningLED Off
		}
	}
	
	// TOGGLE: Silent Runing OFF/ON on Fire
	int initToggleSilentRuningOFFonFire(){
 		SilentRuningOFFonFire=!SilentRuningOFFonFire; // reverse the flag status
		if(DebugMode)printf("Silent Runing On Fire is [%d]\x0a", SilentRuningOFFonFire);
		if(SilentRuningOFFonFire)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSilentRuningonFireLED));					// ToggleSilentRuningLED ON
		if(!SilentRuningOFFonFire)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSilentRuningonFireLED));					// ToggleSilentRuningLED ON
	}
	
	// TOGGLE: HeatSink on Silent Runing
	int initToggleHeatSinkonSilentRuning(){
		HeatSinkonSilentRuning=!HeatSinkonSilentRuning; // reverse the flag status
		if(DebugMode)printf("Heat Sink on Silent Runing is [%d]\x0a", HeatSinkonSilentRuning);
		if(HeatSinkonSilentRuning)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleHeatSinkonSilentRuningLED));					// ToggleSilentRuningLED ON
		if(!HeatSinkonSilentRuning)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleHeatSinkonSilentRuningLED));					// ToggleSilentRuningLED ON
	}	
	
	// TOGGLE: Menu and LED OFF on Idle (Check PERSONAL SETTINGS in Settings File)	
	int initToggleIDLEonThrottle(){
		if(Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(DebugMode)printf("IDLE On Throttle : RESET STATE\x0a");
		}else{
			if(Throttle[IDLELON]) sIDLE = 1; else sIDLE = 0;
			if(GameMenuOnIDLE)ActKey(KEYON+PULSE+GameMenu);
			if(sIDLE){
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, ThrottleLEDOnIDLE));
				if(DebugMode)printf("IDLE On Throttle : IDLE Mode [%d]\x0a", sIDLE);
				if(ToggleIDLEonThrottleLED !=0 & ThrottleLEDOnIDLE !=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleIDLEonThrottleLED));
			}else{
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, vThrottleLightBackup));
				if(DebugMode)printf("IDLE On Throttle : Active Mode [%d]\x0a", sIDLE);
				if(ToggleIDLEonThrottleLED !=0 & ThrottleLEDOnIDLE !=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleIDLEonThrottleLED));
			}
		}
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// FUNCTIONS 																																					//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//		
	
	// FUNCTION FPS & CONNECTION STATUS
	int initFPSCONNECTION(){
		ActKey(KEYON+PULSE+ShowFramerate);
		ActKey(KEYON+PULSE+ShowConnectionStatus);
	}
	
	// FUNCTION: Head Center
	int initHeadCenter(){
		if(HDM){
			ActKey(KEYON+PULSE+HDMCenter);
			if(DebugMode)printf("HDM Center\x0a");
		}
		if(TrackIR){
			ActKey(KEYON+PULSE+TrackIRCenter);
			if(DebugMode)printf("TrackIR Center\x0a");
		}
	}
	
	// FUNCTION: Head Focus
	int initHeadFocus(){
		if(TrackIR){
			if(Throttle[SC]){
				ActKey(KEYON+PULSE+TrackIRPause);
				if(DebugMode)printf("TrackIR Pause\x0a");
			}
		}
		if(HDM){if(DebugMode)printf("HDM\x0a");}
 		if(!HDM & !TrackIR){
			if(Throttle[SC]){			
				ActKey(KEYON+DOWN+UIFocus);
				if(DebugMode)printf("UIFocus ON\x0a");
			}
			else{
				ActKey(KEYON+UP+UIFocus);
				if(DebugMode)printf("UIFocus OFF\x0a");
			}			
		}
	}
	
	// FUNCTION: Voice PTT
	int initVoicePTT(){
		vVoicePTT=!vVoicePTT;
		if(sPTTState){
			if(vVoicePTT){
				if(!sPPTMode)ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
				else ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
				if(DebugMode)printf("External Mic Actived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleVoicePTTLED)); 								// ToggleVoiceLED ON
			}else{
				if(!sPPTMode)ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
				else ActKey(KEYON+UP+ExternalVoiceCommsPTT);
				if(DebugMode)printf("External Mic DesActived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleVoicePTTLED)); 								// ToggleVoiceLED ON
			}
		}
		else{
			if(vVoicePTT){
				if(!sPPTMode)ActKey(KEYON+PULSE+InternalVoiceCommsPTT);
				else ActKey(KEYON+DOWN+InternalVoiceCommsPTT);
				if(DebugMode)printf("Internal Mic Actived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleVoicePTTLED)); 								// ToggleVoiceLED ON
			}else{
				if(!sPPTMode)ActKey(KEYON+PULSE+InternalVoiceCommsPTT);
				else ActKey(KEYON+UP+InternalVoiceCommsPTT);
				if(DebugMode)printf("Internal Mic DesActived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleVoicePTTLED)); 								// ToggleVoiceLED ON
			}
		}
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// GAMES FUNCTIONS 																																				//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	// FUNCTION: Init Primary Fire
	int initPrimaryFire(){
		if(Joystick[TG1]){	
			if (SilentRuningOFFonFire & sSilentRuning){
				vSilentRuningBackup = sSilentRuning;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
			}
			if(sHardPoints == 0){
				ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
			}
			ActKey(KEYON+DOWN+PrimaryFire);
		}else{
			ActKey(KEYON+UP+PrimaryFire);
			if(vSilentRuningBackup!=0){
				vSilentRuningBackup = 0;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
			}
		}
	}
	// FUNCTION: Init Secondary Fire
	int initSecondaryFire(){
		if(Joystick[S2]){
			if (SilentRuningOFFonFire & sSilentRuning){		
				vSilentRuningBackup = sSilentRuning;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
			}				
			if(sHardPoints == 0){
				ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
			}
			ActKey(KEYON+DOWN+SecondaryFire);
		}else{
			ActKey(KEYON+UP+SecondaryFire);
			if(vSilentRuningBackup!=0){
				vSilentRuningBackup = 0;
				ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));
			}
		}
	}
	
	// FUNCTION: Enhanced Joystick Curves tailored for Flight Assist Off (TOGGLE)
	int initEnhancedFAOFF(){																	
		if(Joystick[S4]){
			ActKey(KEYON+PULSE+FlightAssist);
			if(sRCorrection){
				vJoystickCurveProfileBackup = vJoystickCurveProfile;
				vJoystickCurveProfile = FAOffCurve;
				if(DebugMode)printf("EnhancedFAOFF Engaged\x0a");
			}
		}
		if(!Joystick[S4]) {
			ActKey(KEYON+PULSE+FlightAssist);
			if(sRCorrection){
				vJoystickCurveProfile = vJoystickCurveProfileBackup;
				if(DebugMode)printf("EnhancedFAOFF Disengaged\x0a");printf("Curve Profile Return to Default\x0a");
			}
		}
		if(sRCorrection){
			SetSCurve(&Joystick, JOYX, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
			SetSCurve(&Joystick, JOYY, 0, JS_DEADZONE, 0, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
			SetSCurve(&Throttle, SCX, 0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
			SetSCurve(&Throttle, SCY, 0, SL_DEADZONE, 0, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
			if (DebugMode){
				printf("----Joystick Curve Profile[%d]: Curve=%d, Zoom=%d\x0a", vJoystickCurveProfile, JS_CURVE[vJoystickCurveProfile], JS_ZOOM[vJoystickCurveProfile]);
				printf("----Slew     Curve Profile[%d]: Curve=%d, Zoom=%d\x0a", vJoystickCurveProfile, SL_CURVE[vJoystickCurveProfile], SL_ZOOM[vJoystickCurveProfile]);
			}
		}		
	}
	
	// FUNCTION: Jettison All Cargo	
	int initJettisonCargo() {																
		if(Throttle[APUON]){
			if(sCargo){																		
				ActKey(KEYON+PULSE+JettisonAllCargo);
				if(DebugMode)printf("Jettison All Cargo\x0a");
			}else{
				if(DebugMode)printf("Jettison Need Cargo Scoop Open\x0a");
			}
		}
	}
	
	// FUNCTION: Init Supercruise
	int initSuperCruise(){
//		if(SecureRetract & sHardPoints){
//			if(DebugMode)printf("SuperCruise Mode HardPoints\x0a");
//			ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
//		}
		ActKey(KEYON+PULSE+Supercruise);
		if(DebugMode)printf("SuperCruise Engaged\x0a");
	}
	
	// FUNCTION: Init FrameShiftDrive
	int initFrameShiftDrive(){
//		if(SecureRetract & sHardPoints){
//			if(DebugMode)printf("FrameShiftDrive Mode HardPoints\x0a");
//			ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
//		}
		ActKey(KEYON+PULSE+FrameShiftDrive);
		if(DebugMode)printf("FrameShiftDrive Engaged\x0a");
	}
	
	// FUNCTION: SystemJump
	int initSystemJump(){
//		if(SecureRetract){
//			if(sHardPoints){
//				if(DebugMode)printf("SystemJump Mode HardPoints\x0a");
//				ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
//			}
//			if(Gears){
//				if(DebugMode)printf("mSystemJump Mode Gears\x0a");
//				ActKey(KEYON+PULSE+EXEC("initToggleLandingGear();"));
//			}
//			if(Cargo){
//				if(DebugMode)printf("mSystemJump Mode CargoScoop\x0a");
//				ActKey(KEYON+PULSE+EXEC("initToggleCargoScoop();"));
//			}
//		}
		ActKey(KEYON+PULSE+mSystemJump);
		if(DebugMode)printf("SystemJump Engaged\x0a");
	}
	
	// FUNCTION: Use Supercruise while boosting if Throttle is 100%
	int initThrottleBoost() {
		if(SupecruiseOnThrottle){
			if(AxisVal(Throttle[THR_RIGHT], &axdata) >= 32767) {
//				if(SecureRetract & sHardPoints){
//					if(DebugMode)printf("Escape Fight Mode HardPoints\x0a");
//					ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
//				}
				ActKey(KEYON+PULSE+Supercruise);
				if(DebugMode)printf("SupecruiseOnThrottle Engaged\x0a");
			}else{
				ActKey(KEYON+PULSE+EngineBoost);
				if(DebugMode)printf("Engine Boost\x0a");
			}
		}else{
			ActKey(KEYON+PULSE+EngineBoost);
			if(DebugMode)printf("Engine Boost\x0a");
		}
	}
	
	// FUNCTION: Escape Fight
	int initEscapeFight(){
		if(SecureRetract){
			vSecureEscapeFight=!vSecureEscapeFight;
//			if(DebugMode)printf("Escape Mode BEGIN SecureEscapeFightState [%d]\x0a", SecureEscapeFightState);
			if(sHardPoints){
				ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
				if(DebugMode)printf("Escape Fight Mode HardPoints\x0a");
			}
			if(sGears){
				ActKey(KEYON+PULSE+EXEC("initToggleLandingGear();"));
				if(DebugMode)printf("Escape Fight Mode Gears\x0a");
			}
			if(sCargo){
				ActKey(KEYON+PULSE+EXEC("initToggleCargoScoop();"));
				if(DebugMode)printf("Escape Fight Mode CargoScoop\x0a");
			}
			vSecureEscapeFight=!vSecureEscapeFight;
		}
		ActKey(KEYON+PULSE+mEscapeFight);
		if(DebugMode)printf("Escape Mode Engaged : CHECK IF GEARS AND CARGO STATE IS OK (SWITCH WITH S3)\x0a");
//		if(DebugMode)printf("Escape Mode END SecureEscapeFightState [%d]\x0a", SecureEscapeFightState);
	}
	
	// FUNCTION: Request Docking
	int initRCDocking(){
//		if(SecureRetract & sHardPoints){
//			if(DebugMode)printf("Request Docking Mode HardPoints\x0a");
//			ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
//		}
		ActKey(KEYON+PULSE+mRequestCancelDock);
		if(DebugMode)printf("Docking Initialisation\x0a");
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// PIP MANAGEMENT FUNCTIONS 																																	//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	int initPIPmPowerEngSys(){//Advanced PIP Management: 4xENG, 2xSYS	
		ActKey(KEYON+PULSE+mPowerEngSys);
		if(vOptimalPIP != 1) vOptimalPIP = 1;
		if(DebugMode)printf("Initialising PIP Commands 1? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerEngWep(){//Advanced PIP Management: 4xENG, 2xWEP	
		ActKey(KEYON+PULSE+mPowerEngWep);
		if(vOptimalPIP != 2) vOptimalPIP = 2;
		if(DebugMode)printf("Initialising PIP Commands 2? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerSysEng(){//Advanced PIP Management: 4xSYS, 2xENG
		ActKey(KEYON+PULSE+mPowerSysEng);
		if(vOptimalPIP != 3) vOptimalPIP = 3;
		if(DebugMode)printf("Initialising PIP Commands 3? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerSysWep(){//Advanced PIP Management: 4xSYS, 2xWEP
		ActKey(KEYON+PULSE+mPowerSysWep);
		if(vOptimalPIP != 4) vOptimalPIP = 4;
		if(DebugMode)printf("Initialising PIP Commands 4? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerWepEng(){//Advanced PIP Management: 4xWEP, 2xENG
		ActKey(KEYON+PULSE+mPowerWepEng);
		if(vOptimalPIP != 5) vOptimalPIP = 5;
		if(DebugMode)printf("Initialising PIP Commands 5? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerWepSys(){//Advanced PIP Management: 4xWEP, 2xSYS			
		ActKey(KEYON+PULSE+mPowerWepSys);
		if(vOptimalPIP != 6) vOptimalPIP = 6;
		if(DebugMode)printf("Initialising PIP Commands 6? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerTank(){//Advanced PIP Management: 3xWEP, 3xSYS	
		ActKey(KEYON+PULSE+mPowerTank);
		if(vOptimalPIP != 7) vOptimalPIP = 7;
		if(DebugMode)printf("Initialising PIP Commands 7? [%d]\x0a", vOptimalPIP);
	}

	int initPIPmPowerOffensive(){//Advanced PIP Management: 3xWEP, 3xENG
		ActKey(KEYON+PULSE+mPowerOffensive);
		if(vOptimalPIP != 8) vOptimalPIP = 8;
		if(DebugMode)printf("Initialising PIP Commands 8? [%d]\x0a", vOptimalPIP);
	}
