//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	TOGGLE FUNCTIONS																																			//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//TOGGLE: Landing Gear	
	int initToggleLandingGear(){
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(vSecureEscapeFight){
				if(DebugMode)printf("Landing Gear SecureEscapeFight [%d]\x0a", vSecureEscapeFight);
			}
			if(!vSecureEscapeFight){if (Throttle[EACON]) sGears = 1; else sGears = 0;}
			else sGears=!sGears;	//reverse the flag status
			if(sGears & vLG){
				vLG=!vLG;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+LandingGear);			
				if(DebugMode)printf("Landing Gear: DEPLOYED [%d]\x0a", sGears);
				if(ToggleLandingGearLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleLandingGearLED)); 					// ToggleLandingGearLED ON
			}else if (!sGears & !vLG){
				vLG=!vLG;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+LandingGear);
				if(DebugMode)printf("Landing Gear: RETRACTED [%d]\x0a",  sGears);
				if(ToggleLandingGearLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleLandingGearLED)); 					// ToggleLandingGearLED OFF
			}else{
				if(DebugMode)printf("Landing Gear Reset On The Fly\x0a");
			}
		}else{vLG=!vLG;}
	}
	
	//TOGGLE: Cargo Scoop	
	int initToggleCargoScoop() {																
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(vSecureEscapeFight){
				if(DebugMode)printf("Cargo Scoop SecureEscapeFight [%d]\x0a", vSecureEscapeFight);
			}
			if(!vSecureEscapeFight){if (Throttle[RDRNRM]) sCargo = 1; else sCargo = 0;}
			else sCargo=!sCargo;	//reverse the flag status
			if(sCargo & vCS){
				vCS=!vCS;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+CargoScoop);				
				if(DebugMode)printf("Cargo Scoop: DEPLOYED [%d]\x0a", sCargo);
				if(ToggleCargoScoopLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleCargoScoopLED)); 						// ToggleCargoScoopLED ON
			}else if(!sCargo & !vCS){
				vCS=!vCS;	//Reset On The FLY : Just switch
				ActKey(KEYON+PULSE+CargoScoop);
				if(DebugMode)printf("Cargo Scoop: RETRACTED [%d]\x0a", sCargo);
				if(ToggleCargoScoopLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleCargoScoopLED)); 						// ToggleCargoScoopLED OFF
			}else{
				if(DebugMode)printf("Cargo Scoop Reset On The Fly\x0a");
			}
		}else{vCS=!vCS;}
	}

	//TOGGLE: Light	
	int initToggleLights(){
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if (Throttle[EFRNORM]) sLights = 1; else sLights = 0;
			ActKey(KEYON+PULSE+ShipLights);
			if(sLights){																							
				if(DebugMode)printf("Light: ON [%d]\x0a", sLights);
				if(ToggleLightsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleLightsLED));								// ToggleLightsLED ON
			}else{
				if(DebugMode)printf("Light: OFF [%d]\x0a", sLights);
				if(ToggleLightsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleLightsLED));								// ToggleLightsLED OFF
			}
		}
	}
	
	//TOGGLE: HardPoints	
	int initToggleHardpoints(){
		if(Joystick[S3]){
			sHardPoints=!sHardPoints;	//reverse the flag status
			if(DebugMode)printf("HardPoints: State Reset\x0a");
		}		
		if(!Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(vSecureEscapeFight){
				if(DebugMode)printf("HardPoints SecureEscapeFight [%d]\x0a", vSecureEscapeFight);
			}
			sHardPoints=!sHardPoints;	//reverse the flag status
			ActKey(KEYON+PULSE+DeployHardpoints);
			if(sHardPoints){
				if(OptimalPIPMode){
					vOptimalPIPBackup = vOptimalPIP;
					ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));
					if(DebugMode)printf("HardPoints: Optimal PIP Mode Set\x0a");
				}
				if(DebugMode)printf("HardPoints: DEPLOYED [%d]\x0a", sHardPoints);
				if(ToggleHardpointsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleHardpointsLED));					// ToggleHardpointsLED ON
			}else{
				if(OptimalPIPMode){
					if(vOptimalPIPBackup == 0)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,SYS);"));		//If no PIP Mode is switched after the game launch and before Toggle Hardpoints
					if(vOptimalPIPBackup == 1)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,SYS);"));
					if(vOptimalPIPBackup == 2)ActKey(KEYON+PULSE+EXEC("initPIPPower(ENG,WEP);"));
					if(vOptimalPIPBackup == 3)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,ENG);"));
					if(vOptimalPIPBackup == 4)ActKey(KEYON+PULSE+EXEC("initPIPPower(SYS,WEP);"));
					if(vOptimalPIPBackup == 5)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,ENG);"));
					if(vOptimalPIPBackup == 6)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS);"));
					if(vOptimalPIPBackup == 7)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,SYS,MID);"));
					if(vOptimalPIPBackup == 8)ActKey(KEYON+PULSE+EXEC("initPIPPower(WEP,ENG,MID);"));
					if(DebugMode)printf("HardPoints: Optimal PIP Mode Reset [%d]\x0a", vOptimalPIPBackup);
				}
				if(DebugMode)printf("HardPoints: RETRACTED [%d]\x0a", sHardPoints);
				if(ToggleHardpointsLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleHardpointsLED));					// ToggleHardpointsLED OFF
			}
		}
	}
	
	//TOGGLE: Combined Fire	
	int initToggleCombinedFire(){
		if(sCombinedFire){
			MapKey(&Joystick, TG2, CHAIN(PrimaryFire, SecondaryFire));
			if(DebugMode)printf("COMBINED Primary & Secondary Fire 1? [%d]\x0a", sCombinedFire);
			if(ToggleCombinedFireLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleCombinedFireLED));					// ToggleCombinedFireLED ON
		}else{
			MapKey(&Joystick, TG2, 0);
			if(DebugMode)printf("SEPARATE Primary & Secondary Fire 0? [%d]\x0a", sCombinedFire);
			if(ToggleCombinedFireLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleCombinedFireLED));					// ToggleCombinedFireLED OFF
		}
		sCombinedFire=!sCombinedFire;	//reverse the flag status
	}

	//TOGGLE: Rotational Correction
	int initToggleRotationCorrection(){	
		ActKey(KEYON+PULSE+RotationalCorrection);
		if(Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(DebugMode)printf("Rotational Correction: RESET STATE\x0a");
		}else{
			sRCorrection=!sRCorrection;	//reverse the flag status
			if(sRCorrection){
				if(DebugMode)printf("Rotation Correction: ENABLED [%d]\x0a", sRCorrection);
				if(ToggleRCorrectionLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleRCorrectionLED));				// ToggleRotationCorrectionLED ON
			}else{
				if(DebugMode)printf("Rotation Correction: DISABLED [%d]\x0a", sRCorrection);
				if(ToggleRCorrectionLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleRCorrectionLED));				// ToggleRotationCorrectionLED OFF
			}
		}
	}

	//TOGGLE: Classified (External) 'Debug' Camera
	int initToggleCamera(){
		sCameraMode=!sCameraMode;	//reverse the flag status
		ActKey(KEYON+PULSE+ClassifiedCamera);
		if(sCameraMode){
			ActKey(KEYON+PULSE+SetSpeed0);
			DeferCall(60, &ActKey, KEYON+PULSE+SPC);
			if(DebugMode)printf("Classified Camera Mode: ON [%d]\x0a", sCameraMode);
			if(ToggleCameraLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleCameraLED));							// ToggleCameraLED ON
		}else{
			if(DebugMode)printf("Classified Camera Mode: OFF [%d]\x0a", sCameraMode);
			if(ToggleCameraLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleCameraLED));							// ToggleCameraLED OFF
		}
	}
	
	//TOGGLE: PTT/PTP & External/Internal Voice
	int initTogglePTT(){
		if(!Joystick[S3]){																								
			sPPTMode=!sPPTMode;	//reverse the flag status
			if(DebugMode)printf("PTTMode Change [%d]\x0a", sPPTMode);
		}else{
			sPTTState=!sPTTState;	//reverse the flag status
			if(sPTTState){
				if(DebugMode)printf("Mic State External PTT[%d]\x0a", sPTTState);
				if(TogglePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+TogglePTTLED));								// ToggleMicLED ON
			}else{
				if(DebugMode)printf("Mic State Internal PTT[%d]\x0a", sPTTState);
				if(TogglePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-TogglePTTLED));								// ToggleMicLED OFF
			}
		}
	}

	//TOGGLE: Supecruise On Throttle Mode
	int initToggleSuperCruiseMode(){
		SupecruiseOnThrottle=!SupecruiseOnThrottle; // reverse the flag status
		if(SupecruiseOnThrottle){
			if(DebugMode)printf("Supecruise On Throttle Mode: ON [%d]\x0a", SupecruiseOnThrottle);
			if(ToggleSuperCruiseModeLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSuperCruiseModeLED));					// ToggleSuperCruiseModeLED ON
		}else{
			if(DebugMode)printf("Supecruise On Throttle Mode: OFF [%d]\x0a", SupecruiseOnThrottle);
			if(ToggleSuperCruiseModeLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSuperCruiseModeLED));					// ToggleSuperCruiseModeLED OFF
		}
	}
	
	//TOGGLE: Silent Runing
	int initToggleSilentRuning(){
		if(Joystick[H3D] | Joystick[TG1] | Joystick[S2] | !Joystick[TG1] | !Joystick[S2]){
			if(SilentRuningGameMode){	// Silent Runing [TOGGLE] Mode Ingame
				sSL=!sSL;
				if(sSL){	//Silent Runing [TOGGLE] Mode First Pulse Engage
					sSilentRuning=!sSilentRuning; // reverse the flag status
					if(sSilentRuning){
						if(HeatSinkonSilentRuning){
							ActKey(KEYON+PULSE+mHeatSinkonSilentRuning);
							if(DebugMode)printf("Heat Sink On Silent Runing Engaged [%d]\x0a", sSilentRuning);
						}else{
							ActKey(KEYON+PULSE+SilentRunning);
							if(DebugMode)printf("Silent Runing [Toggle] Engaged [%d]\x0a", sSilentRuning);
						}
						if(ToggleSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSilentRuningLED));				// ToggleSilentRuningLED ON
					}
				}
				if(!sSL){	//Silent Runing [TOGGLE] Mode Second Pulse DisEngage
					sSilentRuning=!sSilentRuning;
					ActKey(KEYON+PULSE+SilentRunning);
					if(DebugMode)printf("Silent Runing [Toggle] DisEngaged [%d]\x0a", sSilentRuning);
					if(ToggleSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSilentRuningLED));					// ToggleSilentRuningLED OFF
				}
			}else{	//Silent Runing [HOLD] Mode Engage
				sSilentRuning=!sSilentRuning; // reverse the flag status
				ActKey(KEYON+DOWN+SilentRunning);
				if(DebugMode)printf("Silent Runing [HOLD] Engaged [%d]\x0a", sSilentRuning);
				if(ToggleSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSilentRuningLED));						// ToggleSilentRuningLED ON
			}
		}
		else if(!SilentRuningGameMode & sSilentRuning){		//Silent Runing [HOLD] Mode DisEngage
			sSilentRuning=!sSilentRuning; // reverse the flag status
			ActKey(KEYON+UP+SilentRunning);
			if(DebugMode)printf("Silent Runing [HOLD] DisEngaged [%d]\x0a", sSilentRuning);
			if(ToggleSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSilentRuningLED));							// ToggleSilentRuningLED OFF
		}
	}

	//TOGGLE: Silent Runing OFF/ON on Fire
	int initToggleSilentRuningOFFonFire(){
		SilentRuningOFFonFire=!SilentRuningOFFonFire; // reverse the flag status
		if(DebugMode)printf("Silent Runing On Fire is [%d]\x0a", SilentRuningOFFonFire);
		if(SilentRuningOFFonFire & ToggleSilentRuningonFireLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleSilentRuningonFireLED));				// ToggleSilentRuningLED ON
		if(!SilentRuningOFFonFire & ToggleSilentRuningonFireLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleSilentRuningonFireLED));				// ToggleSilentRuningLED OFF
	}

	//TOGGLE: HeatSink on Silent Runing
	int initToggleHeatSinkonSilentRuning(){
		HeatSinkonSilentRuning=!HeatSinkonSilentRuning; // reverse the flag status
		if(DebugMode)printf("Heat Sink on Silent Runing is [%d]\x0a", HeatSinkonSilentRuning);
		if(HeatSinkonSilentRuning & ToggleHeatSinkonSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleHeatSinkonSilentRuningLED));		// ToggleHeatSinkonSilentRuningLED ON
		if(!HeatSinkonSilentRuning & ToggleHeatSinkonSilentRuningLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleHeatSinkonSilentRuningLED));		// ToggleHeatSinkonSilentRuningLED OFF
	}	
	
	//TOGGLE: Menu and LED OFF on Idle (Check PERSONAL SETTINGS in Settings File)	
	int initToggleIDLEonThrottle(){
		if(Joystick[S3]){																								//Reset On The FLY S3 + SWITCH
			if(DebugMode)printf("IDLE On Throttle : RESET STATE\x0a");
		}else{
			if(Throttle[IDLELON]) sIDLE = 1; else sIDLE = 0;
			if(GameMenuOnIDLE)ActKey(KEYON+PULSE+GameMenu);
			if(sIDLE){
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, ThrottleLEDOnIDLE));
				if(DebugMode)printf("IDLE On Throttle : IDLE Mode [%d]\x0a", sIDLE);
				if(ToggleIDLEonThrottleLED!=0 & ThrottleLEDOnIDLE!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleIDLEonThrottleLED));				// ToggleIDLEonThrottleLED ON
			}else{
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, vThrottleLightBackup));
				if(DebugMode)printf("IDLE On Throttle : Active Mode [%d]\x0a", sIDLE);
				if(ToggleIDLEonThrottleLED!=0 & ThrottleLEDOnIDLE!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleIDLEonThrottleLED));				// ToggleIDLEonThrottleLED OFF
			}
		}
	}

	//TOGGLE: Enhanced Joystick Curves tailored for Flight Assist Off ONLY IF Rotational Correction is Enable
	int initToggleEnhancedFAOFF(){																	
		if(Joystick[S4]){
			if(FlightAssistGameMode){	//FA [TOGGLE] Mode Ingame
				if(!sRCorrection)ActKey(KEYON+PULSE+FlightAssist);
				else{
					sFA=!sFA;	//reverse the flag status
					if(sFA){	//FA [TOGGLE] Mode First Pulse Engage
						ActKey(KEYON+PULSE+FlightAssist);
						if(ToggleFALED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleFALED));					//ToggleFALED ON
						vJoystickCurveProfileBackup = vJoystickCurveProfile;
						vJoystickCurveProfile = FAOffCurve;
						if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset						
							if(DebugMode)printf("EnhancedFAOFF [Toggle] Engaged\x0a");
							ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
						}
					}
					if(!sFA){	//FA [TOGGLE] Mode Second Pulse DisEngage				
						ActKey(KEYON+PULSE+FlightAssist);
						if(ToggleFALED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleFALED));					//ToggleFALED OFF
						vJoystickCurveProfile = vJoystickCurveProfileBackup;
						if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset						
							if(DebugMode)printf("EnhancedFAOFF [Toggle] Disengaged\x0a");printf("Curve Profile Return to Default\x0a");
							ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
						}
					}
				}
			}else{	//FA [HOLD] Mode Ingame Engage
				if(!sRCorrection)ActKey(KEYON+DOWN+FlightAssist);
				else{
					ActKey(KEYON+DOWN+FlightAssist);
					if(ToggleFALED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleFALED));						//ToggleFALED ON
					vJoystickCurveProfileBackup = vJoystickCurveProfile;
					vJoystickCurveProfile = FAOffCurve;
					if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset						
						if(DebugMode)printf("EnhancedFAOFF [HOLD] Engaged\x0a");
						ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
					}
				}
			}
		}
		if(!Joystick[S4]){
			if(!FlightAssistGameMode){	//FA [HOLD] Mode Ingame DisEngage
				if(!sRCorrection)ActKey(KEYON+UP+FlightAssist);	
				else{
					ActKey(KEYON+UP+FlightAssist);
					if(ToggleFALED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleFALED));						//ToggleFALED OFF
					vJoystickCurveProfile = vJoystickCurveProfileBackup;
					if(vJoystickCurveProfileBackup != FAOffCurve){	//Only if Previous Curve is != from FAOffCurrve preset					
						if(DebugMode)printf("EnhancedFAOFF [HOLD] Disengaged\x0a");printf("Curve Profile Return to Default\x0a");
						ActKey(KEYON+PULSE+EXEC("initJoystickCurves();"));
					}
				}
			}
		}
	}
	
	//TOGGLE: Reverse Throttle
	int initToggleReverseThrottle(){
		if(Throttle[LTB]){
			sRT=!sRT;
			if(RFlightThrootleGameMode){ActKey(KEYON+PULSE+ReverseThrottle);if(DebugMode)printf("Reverse Throttle Toggle\x0a");}
			else{ActKey(KEYON+DOWN+ReverseThrottle);if(DebugMode)printf("Reverse Throttle Hold on\x0a");}
		}else{
			if(!RFlightThrootleGameMode & sRT){
				sRT=!sRT;
				ActKey(KEYON+UP+ReverseThrottle);
				if(DebugMode)printf("Reverse Throttle Hold off\x0a");
			}
		}
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	FUNCTIONS																																					//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//		
	
	//FUNCTION FPS & CONNECTION STATUS
	int initFPSCONNECTION(){
		ActKey(KEYON+PULSE+ShowFramerate);
		ActKey(KEYON+PULSE+ShowConnectionStatus);
	}
	
	//FUNCTION: Head Center
	int initHeadCenter(){
		if(HDM){
			ActKey(KEYON+PULSE+HDMCenter);
			if(DebugMode)printf("HDM Center\x0a");
		}
		if(TrackIR){
			ActKey(KEYON+PULSE+TrackIRCenter);
			if(DebugMode)printf("TrackIR Center\x0a");
		}
	}
	
	//FUNCTION: Head Focus
	int initHeadFocus(){
		if(TrackIR){
			if(Throttle[SC]){
				ActKey(KEYON+PULSE+TrackIRPause);
				if(DebugMode)printf("TrackIR Pause\x0a");
			}
		}
		if(HDM){if(DebugMode)printf("HDM\x0a");}
		if(!HDM & !TrackIR){
			if(Throttle[SC]){			
				ActKey(KEYON+DOWN+UIFocus);
				if(DebugMode)printf("UIFocus ON\x0a");
			}
			else{
				ActKey(KEYON+UP+UIFocus);
				if(DebugMode)printf("UIFocus OFF\x0a");
			}			
		}
	}
	
	//FUNCTION: Voice PTT
	int initVoicePTT(){
		vVoicePTT=!vVoicePTT;
		if(sPTTState){
			if(vVoicePTT){
				if(!sPPTMode)ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
				else ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
				if(DebugMode)printf("External Mic Actived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleVoicePTTLED));								// ToggleVoiceLED ON
			}else{
				if(!sPPTMode)ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
				else ActKey(KEYON+UP+ExternalVoiceCommsPTT);
				if(DebugMode)printf("External Mic DesActived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleVoicePTTLED));								// ToggleVoiceLED ON
			}
		}
		else{
			if(vVoicePTT){
				if(!sPPTMode)ActKey(KEYON+PULSE+InternalVoiceCommsPTT);
				else ActKey(KEYON+DOWN+InternalVoiceCommsPTT);
				if(DebugMode)printf("Internal Mic Actived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+ToggleVoicePTTLED));								// ToggleVoiceLED ON
			}else{
				if(!sPPTMode)ActKey(KEYON+PULSE+InternalVoiceCommsPTT);
				else ActKey(KEYON+UP+InternalVoiceCommsPTT);
				if(DebugMode)printf("Internal Mic DesActived [%d] PTT State [%d] Mode [%d]\x0a", vVoicePTT, sPTTState, sPPTMode);
				if(ToggleVoicePTTLED!=0)ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-ToggleVoicePTTLED));								// ToggleVoiceLED ON
			}
		}
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	GAMES FUNCTIONS																																				//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	//FUNCTION: Init Primary Fire
	int initPrimaryFire(){
		if(Joystick[TG1]){	//PRESS THE TG1 BUTTON	
			if(SilentRuningOFFonFire & sSilentRuning){vSilentRuningBackup = sSilentRuning;	ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}
//			if(SilentRuningOFFonFire & sSilentRuning & SilentRuningGameMode){vSilentRuningBackup = sSilentRuning;	ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}
			if(HardPointsonFireGameMode){
				if(sHardPoints == 0){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			}
			ActKey(KEYON+DOWN+PrimaryFire);
		}else{				//RELEASE THE TG1 BUTTON
			ActKey(KEYON+UP+PrimaryFire);
			if(vSilentRuningBackup!=0){vSilentRuningBackup = 0;	ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}
		}
	}
	
	//FUNCTION: Init Secondary Fire
	int initSecondaryFire(){
		if(Joystick[S2]){	//PRESS THE S2 BUTTON
			if(SilentRuningOFFonFire & sSilentRuning){vSilentRuningBackup = sSilentRuning;	ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}
//			if(SilentRuningOFFonFire & sSilentRuning & SilentRuningGameMode){vSilentRuningBackup = sSilentRuning;	ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}			
			if(HardPointsonFireGameMode){
				if(sHardPoints == 0){ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));}
			}
			ActKey(KEYON+DOWN+SecondaryFire);
		}else{				//RELEASE THE S2 BUTTON
			ActKey(KEYON+UP+SecondaryFire);
			if(vSilentRuningBackup!=0){vSilentRuningBackup = 0;	ActKey(KEYON+PULSE+EXEC("initToggleSilentRuning();"));}
		}
	}
	
	//FUNCTION: Jettison All Cargo	
	int initJettisonCargo(){																
		if(Throttle[APUON]){
			if(sCargo){																		
				ActKey(KEYON+PULSE+JettisonAllCargo);
				if(DebugMode)printf("Jettison All Cargo\x0a");
			}else{
				if(DebugMode)printf("Jettison Need Cargo Scoop Open\x0a");
			}
		}
	}

	//FUNCTION: Init Secure Retract
	int initSecureRectract(){
		vSecureEscapeFight=!vSecureEscapeFight;
		if(sHardPoints)ActKey(KEYON+PULSE+EXEC("initToggleHardpoints();"));
		if(sGears)ActKey(KEYON+PULSE+EXEC("initToggleLandingGear();"));
		if(sCargo)ActKey(KEYON+PULSE+EXEC("initToggleCargoScoop();"));
		vSecureEscapeFight=!vSecureEscapeFight;
	}

	//FUNCTION: Init Supercruise
	int initSuperCruise(){
		if(SecureRetract)ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+Supercruise);
		if(DebugMode)printf("SuperCruise Engaged\x0a");
	}
	
	//FUNCTION: Init FrameShiftDrive
	int initFrameShiftDrive(){
		if(SecureRetract)ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+FrameShiftDrive);
		if(DebugMode)printf("FrameShiftDrive Engaged\x0a");
	}
	
	//FUNCTION: SystemJump
	int initSystemJump(){
		if(SecureRetract)ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+mSystemJump);
		if(DebugMode)printf("SystemJump Engaged\x0a");
	}
	
	//FUNCTION: Use Supercruise while boosting if Throttle is 100%
	int initThrottleBoost(){
		if(SupecruiseOnThrottle){
			if(AxisVal(Throttle[THR_RIGHT], &axdata) >= 32767){
				if(SecureRetract)ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
				ActKey(KEYON+PULSE+Supercruise);
				if(DebugMode)printf("SupecruiseOnThrottle Engaged\x0a");
			}else{
				ActKey(KEYON+PULSE+EngineBoost);
				if(DebugMode)printf("Engine Boost\x0a");
			}
		}else{
			ActKey(KEYON+PULSE+EngineBoost);
			if(DebugMode)printf("Engine Boost\x0a");
		}
	}
	
	//FUNCTION: Escape Fight
	int initEscapeFight(){
		if(SecureRetract){ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		}
		ActKey(KEYON+PULSE+mEscapeFight);
		if(DebugMode)printf("Escape Mode Engaged : CHECK IF GEARS AND CARGO STATE IS OK (SWITCH CS and LG)\x0a");
	}
	
	//FUNCTION: Request Docking
	int initRCDocking(){
		if(SecureRetract)ActKey(KEYON+PULSE+EXEC("initSecureRectract();"));
		ActKey(KEYON+PULSE+mRequestCancelDock);
		if(DebugMode)printf("Docking Initialisation\x0a");
	}

	//FUNCTION: Autopilot Engage / Disengage Key
	int initEngageAPkey(){
		if (Throttle[APPAT]) ActKey(KEYON+PULSE+EXEC("initRCDocking();"));
		if (Throttle[APAH]) ActKey(KEYON+PULSE+EXEC("initEscapeFight();"));
		if (Throttle[APALT] & !Joystick[S3]) ActKey(KEYON+PULSE+EXEC("initSystemJump();"));
		if (Throttle[APALT] & Joystick[S3]) ActKey(KEYON+PULSE+CancelFSD);
	}
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//	PIP MANAGEMENT FUNCTIONS CREDIT TO DarKcyde0																																	//
// 		initPIPPower sets PIPs as requested, Params = SYS, ENG, WEP, MID
//		1st Param gets 4 PIPs, 2nd gets 2 PIPs, 3eme get 50/50 of 1st and 2nd Param if [MID]
// 		If no 2nd param, balanced 1 PIP on each 2ndary power
// 		If no params, balances power.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
	
	int initPIPPower(int x=0, int y=0, int z=0){

		// Map out PIPs
		if (x == 0) PIPfull = 0;
		else if (x == SYS) PIPfull = PULSE+ PowerSys;
		else if (x == ENG) PIPfull = PULSE+ PowerEng;
		else if (x == WEP) PIPfull = PULSE+ PowerWep;
	
		if (y == 0) PIPhalf = 0;
		else if (y == SYS) PIPhalf = PULSE+ PowerSys;
		else if (y == ENG) PIPhalf = PULSE+ PowerEng;
		else if (y == WEP) PIPhalf = PULSE+ PowerWep;

		if (z == 0) PIPMid = 0;
		else if (z == MID) PIPMid = PIPfull;
		
		// Send PIPS
		ActKey(KEYON+ CHAIN(PULSE+ BalancePower, D(),PIPfull, D(),PIPhalf, D(),PIPfull, D(),PIPMid, D(),PIPfull));
		
		// Save the PIPS for Automatique PIP MOD RESET (OptimalPIPMode in Settings File)
		if		(x == ENG & y == SYS & z != MID){if(vOptimalPIP != 1) vOptimalPIP = 1;if(DebugMode)printf("Initialising PIP Commands 1? [%d]\x0a", vOptimalPIP);}
		else if	(x == ENG & y == WEP & z != MID){if(vOptimalPIP != 2) vOptimalPIP = 2;if(DebugMode)printf("Initialising PIP Commands 2? [%d]\x0a", vOptimalPIP);}
		else if	(x == SYS & y == ENG & z != MID){if(vOptimalPIP != 3) vOptimalPIP = 3;if(DebugMode)printf("Initialising PIP Commands 3? [%d]\x0a", vOptimalPIP);}
		else if	(x == SYS & y == WEP & z != MID){if(vOptimalPIP != 4) vOptimalPIP = 4;if(DebugMode)printf("Initialising PIP Commands 4? [%d]\x0a", vOptimalPIP);}
		else if	(x == WEP & y == ENG & z != MID){if(vOptimalPIP != 5) vOptimalPIP = 5;if(DebugMode)printf("Initialising PIP Commands 5? [%d]\x0a", vOptimalPIP);}
		else if	(x == WEP & y == SYS & z != MID){if(vOptimalPIP != 6) vOptimalPIP = 6;if(DebugMode)printf("Initialising PIP Commands 6? [%d]\x0a", vOptimalPIP);}
		else if	(x == WEP & y == SYS & z == MID){if(vOptimalPIP != 7) vOptimalPIP = 7;if(DebugMode)printf("Initialising PIP Commands 7? [%d]\x0a", vOptimalPIP);}
		else if	(x == WEP & y == ENG & z == MID){if(vOptimalPIP != 8) vOptimalPIP = 8;if(DebugMode)printf("Initialising PIP Commands 8? [%d]\x0a", vOptimalPIP);}
	}